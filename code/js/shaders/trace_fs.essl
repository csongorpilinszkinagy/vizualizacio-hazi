Shader.source[document.currentScript.src.split('js/shaders/')[1]] = `
	precision highp float;
	uniform vec3 eye;
	uniform sampler2D volume;
	uniform sampler2D texture;

	varying vec3 rayDir;

	bool inCube(vec3 pos) {
		if (pos.x > 0.0 && pos.x < 1.0 && pos.y > 0.0 && pos.y < 1.0 && pos.z > 0.0 && pos.z < 1.0)
			return true;
		return false;
	}

	vec2 inTexCoord(vec3 pos) {
		float modZ = mod(floor(pos.z * 256.0), 16.0);
		return vec2(pos.x, -pos.y) / 16.0 + vec2(modZ / 16.0, (floor(pos.z * 256.0) - modZ) / 256.0);
	}

	float sampleVolume(vec3 pos) {
		if (!inCube(pos)) return 0.0;

		vec2 coord1 = inTexCoord(pos);
		vec2 coord2 = inTexCoord(pos + vec3(0.0, 0.0, 1.0/256.0));

		float sample1 = texture2D(volume, coord1).x;
		float sample2 = texture2D(volume, coord2).x;

		return mix(sample1, sample2, fract(pos.z));
	}

	void main() {
		vec3 d = normalize(rayDir);

		float t1 = (1.0 - eye.y) / d.y;
		float t2 = (0.0 - eye.y) / d.y;

		float t_start = max(min(t1, t2), 0.0);
		float t_end = max(max(t1, t2), 0.0);

		vec3 pos = eye;
		float step = min((t_end - t_start) / 100.0, 0.05);

		for (int i = 0; i < 100; i++) {
			float sample = sampleVolume(pos);
			if (sample > 0.05)
				break;
			pos += d * step;
		}

		t_end = (pos - eye).y / d.y;
		step = (t_end - t_start) / 2.0;

		pos = eye;
		for (int i=0; i<20; i++) {
			float sample = sampleVolume(pos);
			if (sample > 0.05)
				pos -= d * step;
			else
				pos += d*step;
			step /= 2.0;
		}

		float sample = sampleVolume(pos);

		if (sample > 0.0) {
			vec3 grad = vec3(
				(sampleVolume(pos + vec3(0.001, 0.0, 0.0)) - sampleVolume(pos + vec3(-0.001, 0.0, 0.0))),
				(sampleVolume(pos + vec3(0.0, 0.001, 0.0)) - sampleVolume(pos + vec3(0.0, -0.001, 0.0))),
				(sampleVolume(pos + vec3(0.0, 0.0, 0.001)) - sampleVolume(pos + vec3(0.0, 0.0, -0.001)))
			);

			vec3 norm = -normalize(grad);
			vec4 color = texture2D(texture, vec2(norm.x, norm.y));
			gl_FragColor = vec4(norm, 1.0);
			return;
		}

		gl_FragColor = vec4(0.1, 0.1, 0.1, 1.0); 
	}
`;